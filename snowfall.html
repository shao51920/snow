<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Êº´Â§©È£ûÈõ™</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background-color: #000;
            font-family: 'Microsoft YaHei', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: pan-y;
        }

        canvas {
            display: block;
            touch-action: none;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            z-index: 100;
        }

        #toggle-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s;
        }

        #toggle-btn:active {
            transform: scale(0.95);
        }

        #ui-panel {
            width: 280px;
            max-width: calc(100vw - 40px);
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.15);
            transition: opacity 0.3s, transform 0.3s;
            transform-origin: top right;
        }

        #ui-panel.collapsed {
            opacity: 0;
            transform: scale(0.9) translateY(-20px);
            pointer-events: none;
        }

        h1 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #0077cc;
            text-align: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 12px;
            color: #555;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #0077cc;
        }

        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            cursor: pointer;
        }

        input[type="checkbox"] {
            cursor: pointer;
            accent-color: #0077cc;
        }

        .instructions {
            font-size: 11px;
            color: #666;
            margin-top: 10px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            padding-top: 8px;
        }

        ul {
            padding-left: 18px;
            margin: 0;
        }

        li {
            margin-bottom: 3px;
        }
    </style>
</head>

<body>
    <canvas id="snowCanvas"></canvas>

    <div id="ui-container">
        <button id="toggle-btn">‚öôÔ∏è</button>
        <div id="ui-panel">
            <h1>‚ùÑÔ∏è 3D Èõ™ÊôØÊéßÂà∂Âè∞</h1>

            <div class="control-group">
                <label>ËÉåÊôØÈ¢úËâ≤</label>
                <input type="color" id="bgColor" value="#87CEEB">
            </div>
            <div class="control-group">
                <label>ËÉåÊôØÊ∑±ÊµÖ</label>
                <input type="range" id="bgDarkness" min="0" max="1" step="0.05" value="0.2">
            </div>

            <hr style="border: 0; border-top: 1px solid rgba(0,0,0,0.1); margin: 10px 0;">

            <div class="control-group">
                <label>Èõ™Ëä±ÂØÜÂ∫¶ <span id="val-density">600</span></label>
                <input type="range" id="density" min="100" max="4000" step="50" value="600">
            </div>
            <div class="control-group">
                <label>‰∏ãËêΩÈÄüÂ∫¶ <span id="val-speed">1.0</span></label>
                <input type="range" id="speed" min="0.1" max="10" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Èõ™Ëä±Â§ßÂ∞è <span id="val-size">1.0</span></label>
                <input type="range" id="size" min="0.1" max="5" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>È£éÂäõ <span id="val-wind">0.5</span></label>
                <input type="range" id="wind" min="-10" max="10" step="0.1" value="0.5">
            </div>
            <div class="control-group">
                <label style="align-items: center;">
                    <span>È£éÂêëÈöèÊú∫ÊÄß</span>
                    <input type="checkbox" id="windChaos" style="width: auto; margin: 0;">
                </label>
            </div>

            <div class="instructions">
                <ul>
                    <li>üñ±Ô∏è ÊãñÊãΩÊóãËΩ¨ËßÜËßí</li>
                    <li>‚ùÑÔ∏è Êô∂‰Ωì+È¢óÁ≤íÊ∑∑Âêà</li>
                    <li>üì± ÊîØÊåÅËß¶Êë∏Êìç‰Ωú</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('snowCanvas');
        const ctx = canvas.getContext('2d');
        const isMobile = /Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent);

        const CONFIG = {
            particleCount: isMobile ? 300 : 600,
            baseSpeed: 1,
            baseSize: 1,
            baseWind: 0.5,
            windChaos: false,
            fov: 800,
            bgColor: '#87CEEB',
            bgDarkness: 0.2
        };

        let width, height, particles = [], textures = [];
        let angleX = 0, angleY = 0, isDragging = false, lastX = 0, lastY = 0;

        document.getElementById('toggle-btn').addEventListener('click', () => {
            document.getElementById('ui-panel').classList.toggle('collapsed');
        });

        function createSnowflakeTexture() {
            const size = 64, c = document.createElement('canvas');
            c.width = c.height = size;
            const tCtx = c.getContext('2d'), center = size / 2;
            tCtx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
            tCtx.lineWidth = 2;
            tCtx.lineCap = 'round';
            tCtx.shadowBlur = 4;
            tCtx.shadowColor = 'rgba(255, 255, 255, 0.6)';
            tCtx.translate(center, center);

            const branches = 6, radius = size / 2 - 4, irregularity = Math.random();
            for (let i = 0; i < branches; i++) {
                tCtx.save();
                tCtx.rotate((Math.PI * 2 / branches) * i + (Math.random() - 0.5) * irregularity * 0.5);
                const branchLen = radius * (0.7 + Math.random() * 0.3);
                tCtx.beginPath();
                tCtx.moveTo(0, 0);
                tCtx.lineTo(0, -branchLen);
                tCtx.stroke();

                const subBranches = Math.floor(Math.random() * 4) + 1;
                for (let j = 0; j < subBranches; j++) {
                    const dist = (j + 1) / (subBranches + 1) * branchLen;
                    const subLen = (branchLen - dist) * 0.6 * (0.5 + Math.random() * 0.5);
                    tCtx.beginPath();
                    tCtx.moveTo(0, -dist);
                    tCtx.lineTo(-subLen * 0.8, -dist - subLen * 0.5);
                    tCtx.stroke();
                    tCtx.beginPath();
                    tCtx.moveTo(0, -dist);
                    tCtx.lineTo(subLen * 0.8, -dist - subLen * 0.5);
                    tCtx.stroke();
                }
                if (Math.random() > 0.7) {
                    tCtx.beginPath();
                    tCtx.arc(0, -branchLen * 0.5, branchLen * 0.1, 0, Math.PI * 2);
                    tCtx.fillStyle = 'rgba(255,255,255,0.3)';
                    tCtx.fill();
                }
                tCtx.restore();
            }
            if (Math.random() > 0.5) {
                tCtx.beginPath();
                tCtx.arc(0, 0, radius * 0.2 * Math.random(), 0, Math.PI * 2);
                tCtx.fillStyle = 'rgba(255,255,255,0.8)';
                tCtx.fill();
            }
            return c;
        }

        function createParticleTexture() {
            const size = 16, c = document.createElement('canvas');
            c.width = c.height = size;
            const tCtx = c.getContext('2d'), center = size / 2, radius = Math.random() * 3 + 2;
            const gradient = tCtx.createRadialGradient(center, center, 0, center, center, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            tCtx.fillStyle = gradient;
            tCtx.beginPath();
            tCtx.arc(center, center, radius, 0, Math.PI * 2);
            tCtx.fill();
            return c;
        }

        function generateTextures() {
            textures = [];
            for (let i = 0; i < 12; i++) textures.push(createSnowflakeTexture());
            for (let i = 0; i < 8; i++) textures.push(createParticleTexture());
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();
        generateTextures();

        class Particle {
            constructor() { this.reset(true); }
            reset(initial = false) {
                const range = 2000;
                this.x = (Math.random() - 0.5) * range;
                this.y = initial ? (Math.random() - 0.5) * range : -range / 2 - 100;
                this.z = (Math.random() - 0.5) * range;
                this.texture = textures[Math.floor(Math.random() * textures.length)];
                this.scale = Math.random() * 0.5 + 0.5;
                this.fallSpeed = Math.random() * 2 + 1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;
            }
            update() {
                this.y += this.fallSpeed * CONFIG.baseSpeed;
                let windForce = CONFIG.baseWind;
                if (CONFIG.windChaos) windForce += (Math.random() - 0.5) * 2;
                this.x += windForce;
                this.rotation += this.rotationSpeed;
                const range = 1000;
                if (this.y > range) this.y = -range;
                if (this.x > range) this.x = -range;
                if (this.x < -range) this.x = range;
                if (this.z > range) this.z = -range;
                if (this.z < -range) this.z = range;
            }
            draw() {
                let x1 = this.x * Math.cos(angleY) - this.z * Math.sin(angleY);
                let z1 = this.z * Math.cos(angleY) + this.x * Math.sin(angleY);
                let y1 = this.y * Math.cos(angleX) - z1 * Math.sin(angleX);
                let z2 = z1 * Math.cos(angleX) + this.y * Math.sin(angleX);
                let scale = CONFIG.fov / (CONFIG.fov + z2);
                if (scale < 0 || z2 < -CONFIG.fov + 50) return;
                let x2d = x1 * scale + width / 2;
                let y2d = y1 * scale + height / 2;
                let size = 40 * this.scale * scale * CONFIG.baseSize;
                ctx.save();
                ctx.translate(x2d, y2d);
                ctx.scale(scale, scale);
                ctx.rotate(this.rotation);
                ctx.globalAlpha = Math.min(1, (z2 + 1000) / 2000);
                ctx.drawImage(this.texture, -size / 2, -size / 2, size, size);
                ctx.restore();
            }
        }

        function init() {
            particles = [];
            for (let i = 0; i < CONFIG.particleCount; i++) particles.push(new Particle());
        }
        init();

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            angleY += (e.clientX - lastX) * 0.005;
            angleX += (e.clientY - lastY) * 0.005;
            angleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, angleX));
            lastX = e.clientX;
            lastY = e.clientY;
        });
        canvas.addEventListener('mouseup', () => { isDragging = false; });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            isDragging = true;
            lastX = touch.clientX;
            lastY = touch.clientY;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const touch = e.touches[0];
            angleY += (touch.clientX - lastX) * 0.005;
            angleX += (touch.clientY - lastY) * 0.005;
            angleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, angleX));
            lastX = touch.clientX;
            lastY = touch.clientY;
        }, { passive: false });

        canvas.addEventListener('touchend', () => { isDragging = false; });

        function updateConfig(id, key, isFloat = true) {
            const el = document.getElementById(id);
            const valSpan = document.getElementById('val-' + id);
            el.addEventListener('input', (e) => {
                const val = isFloat ? parseFloat(e.target.value) : e.target.value;
                CONFIG[key] = val;
                if (valSpan) valSpan.textContent = val.toFixed(1);
            });
        }

        updateConfig('speed', 'baseSpeed');
        updateConfig('size', 'baseSize');
        updateConfig('wind', 'baseWind');
        updateConfig('bgColor', 'bgColor', false);
        updateConfig('bgDarkness', 'bgDarkness');

        document.getElementById('density').addEventListener('input', (e) => {
            CONFIG.particleCount = parseInt(e.target.value);
            document.getElementById('val-density').textContent = CONFIG.particleCount;
            init();
        });

        document.getElementById('windChaos').addEventListener('change', (e) => {
            CONFIG.windChaos = e.target.checked;
        });

        function animate() {
            requestAnimationFrame(animate);
            ctx.fillStyle = CONFIG.bgColor;
            ctx.fillRect(0, 0, width, height);
            const darkGrad = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, height);
            darkGrad.addColorStop(0, 'rgba(0,0,0,0)');
            darkGrad.addColorStop(1, `rgba(0,0,0,${CONFIG.bgDarkness})`);
            ctx.fillStyle = darkGrad;
            ctx.fillRect(0, 0, width, height);
            for (let p of particles) {
                p.update();
                p.draw();
            }
        }
        animate();
    </script>
</body>

</html>